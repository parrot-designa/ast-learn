/**
 * 用于匹配一系列 Unicode 字符集中的字符
 */
export const unicodeRegExp =
  /a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/

/**
   * unicodeRegExp.source 是对正则表达式对象 unicodeRegExp 的源码字符串表示
   * source 属性返回创建正则表达式时使用的原始字符串，不包括正则表达式前面的斜杠 / 以及可能的标志（如 i 表示忽略大小写，m 表示多行模式等）
   * 1. 起始字符必须是字母（大写或小写）或下划线 _
   * 2. 后续字符可以是连字符 -，点 .，数字 0-9，下划线 _，字母 a-zA-Z，以及由 unicodeRegExp.source 匹配的任何Unicode字符。
   * 3. *：表示上述字符可以出现零次或多次。
*/ 
const ncname = `[a-zA-Z_][\\-\\.0-9_a-zA-Z${unicodeRegExp.source}]*`
/**
 * qnameCapture 是一个正则表达式，它被设计用来捕获所谓的“限定名称”（Qualified Names，简称QNames）。
 * 在XML和其他类似的标记语言中，QNames用于标识元素和属性，它们可以包含一个可选的前缀和一个本地部分，两者之间用冒号（:）分隔。
 * 如果没有前缀，那么就只有本地部分。
 * 
 * 1. ${ncname}：这里引用了之前定义的 ncname 正则表达式，用于匹配非冒号开头的名称。
 *      ncname 可以匹配字母、数字、下划线、连字符、点以及一系列Unicode字符（由 unicodeRegExp 定义）。
 * 2. (?:${ncname}\\:)?：这部分是一个非捕获组（non-capturing group），由 (?: ... ) 表示，意味着它不会创建一个额外的捕获组。
 *      这个组中的内容是可选的，表示可能存在的前缀。${ncname}\\: 指的是 ncname 后跟一个冒号，表示前缀部分。
 * 3. ${ncname}：再次引用 ncname，用于匹配本地部分，也就是冒号后面的那部分名称。
 * 
 * 整个 qnameCapture 正则表达式的结构意味着它将匹配以下两种情况之一：
 * 1. 一个完整的 QName，包含前缀和本地部分，中间用冒号分隔。
 * 2. 仅包含本地部分的 QName，没有前缀。
 * 
 * 通过使用 () 来包围整个表达式，qnameCapture 创建了一个捕获组，这意味着当你使用这个正则表达式去匹配文本时，整个匹配到的 QName 将作为一个单独的组被捕获，便于后续处理和提取
 * 例如，如果有一个字符串 "prefix:localPart"，qnameCapture 将匹配整个 "prefix:localPart" 并将其作为一个捕获组返回；如果字符串是 "justLocal", 则会匹配 "justLocal" 作为捕获组。
 */
const qnameCapture = `((?:${ncname}\\:)?${ncname})`
/**
 * 用于在字符串中匹配HTML或XML开始标签的开头部分
 * 1. ^：这是一个断言，表示匹配必须发生在输入字符串的开始位置。换句话说，startTagOpen 只会在字符串的最前面尝试匹配。
 * 2. <：字面量字符 <，用于匹配HTML/XML开始标签的开标签符号。
 * 3. ${qnameCapture}：这是嵌入的表达式，它会被解析为之前定义的 qnameCapture 正则表达式的源码。qnameCapture是用于匹配限定名称（Qualified Name，即元素名，可能包含前缀和本地名）的正则表达式。
 * 
 * 因此，startTagOpen 正则表达式将匹配满足以下条件的字符串：
 * 1. 开始于 < 符号。
 * 2. 紧接着 < 是一个有效的限定名称（QName），这可以是带有前缀的元素名，也可以是没有前缀的元素名。
 */
export const startTagOpen = new RegExp(`^<${qnameCapture}`)

/**
 * 用于匹配HTML或XML开始标签的结束部分，即 > 字符及其可能的前导空白字符，以及可选的结束标签斜杠 /
 * 
 * 具体地，startTagClose 正则表达式的各个组成部分解析如下：
 * 1. ^：断言，表示匹配必须从字符串的开始位置进行。
 * 2. \s*：匹配任意数量的空白字符（包括空格、制表符、换页符等）。这里的星号 * 表示前面的模式（即空白字符）可以出现零次或多次。
 * 3. (\/?)：一个非捕获组，用于匹配可选的斜杠 /。斜杠是HTML中自闭合标签（也称为自结束标签）的一部分，例如 <img src="image.jpg" />。括号内的问号 ? 表示斜杠出现的次数为零或一次，即斜杠是可选的。
 * 4. >：匹配开始标签的结束符号。
 * 
 * 因此，startTagClose 正则表达式将匹配以下几种模式：
 * 1. 仅一个 > 字符，前面可能有任意数量的空白字符，这通常用于普通开始标签的结束，例如 <div class="container">。
 * 2. /> 序列，前面也可能有任意数量的空白字符，这用于自闭合标签的结束，例如 <br /> 或 <meta charset="UTF-8" />。
 * 
 * 这个正则表达式在HTML或XML解析器中非常有用，因为它帮助解析器识别开始标签何时结束，以及该标签是否是自闭合的。一旦开始标签的结束部分被识别，解析器就可以相应地处理标签内容或属性，然后继续解析文档的其余部分。
 */
export const startTagClose = /^\s*(\/?)>/

/**
 * 1. ^：断言，表示匹配必须从字符串的开始位置进行。
 * 2. \s*：匹配任意数量的空白字符（包括空格、制表符、换页符等）。这里的星号 * 表示前面的模式（即空白字符）可以出现零次或多次。
 * 3. (?:v-[\w-]+:|@|:|#) 主要用于匹配几种不同的模式，通常在解析某种模板语言或标记语言（如Vue.js模板语法）时使用
 *     1. (?: ...): 这是非捕获括号，意味着这部分正则表达式不会创建一个捕获组。它只用于分组，但不保存匹配的结果。
 *     2. v-[\w-]+:: 这部分用于匹配形如 v-something: 的模式，其中 something 可以是由字母、数字、下划线或连字符组成的字符串。在Vue.js中，v- 前缀通常用于表示指令（Directives），如 v-if、v-for 等。这里的 + 表示至少匹配一个以上的字符。
 *     3. @: 这个字符在Vue.js模板语法中用于绑定事件处理器，例如 @click="doSomething"。
 *     4. `:` :这个字符在Vue.js中用于动态绑定属性，例如 :class="{ active: isActive }"。
 *     5. #: 在某些模板语法中，# 可以用于特殊的作用域插槽或模板插槽的标记，虽然在Vue.js中通常使用 v-slot 或简写为 # 来定义插槽。
 * 
 * 综上所述，这个正则表达式 (?:v-[\w-]+:|@|:|#) 旨在匹配Vue.js模板中用于指令、事件监听器、属性绑定和插槽的前缀或符号。它能够识别出以下几种模式：
 * - Vue指令，如 v-if:、v-for:、v-model: 等。
 * - 事件监听器绑定，如 @click。
 * - 动态属性绑定，如 :class。
 * - 插槽，使用 # 标记。
 * 这种正则表达式在解析Vue.js模板时非常有用，因为它可以帮助识别和提取出模板中的动态部分，以便于进一步的编译或处理。
 *      
 * 这个正则表达式可能用于匹配具有特定前缀（如 v- 开头的特定格式、@ 、 : 、 # ），紧跟着方括号内特定内容，然后可能跟随一个等号和不同类型的值（双引号、单引号或无引号的特定字符序列）的字符串
 * 例如，它可能匹配以下字符串：
 * 1. v-myAttr:[value]
 * 2. @[attr] = "hello"
 * 3. :#[key] = 'world'
 */
export const dynamicArgAttribute =
  /^\s*((?:v-[\w-]+:|@|:|#)\[[^=]+?\][^\s"'<>\/=]*)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/

/**
 * - 该正则表达式在 HTML 标签属性解析中的应用
 * 
 * 这个正则表达式在 HTML 标签属性解析方面发挥着重要作用。在 HTML 中，标签通常带有各种属性，例如<img src="image.jpg" alt="An image" />，其中src和alt就是属性。此正则表达式能够精确地匹配和提取这些属性的名称和值。
 * 例如，它可以从复杂的 HTML 代码中识别出<div class="main" id="myDiv">中的class和main、id和myDiv等属性对。它通过巧妙地运用各种规则来应对属性值的多种可能形式，比如双引号括起来的值"main"、单引号括起来的值'myDiv'，或者没有引号直接跟随的值。这种精确的解析能力有助于处理 HTML 页面中的大量属性数据，为进一步的操作，如修改、验证或提取特定属性信息提供了基础。
 */
export const attribute =
  /^\s*([^\s"'<>\/=]+)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/

/**
 * 为什么v-if是根据attribute正则进行匹配的
 * 
 * 在Vue.js中，v-if 以及其他的Vue指令（如 v-for, v-bind, v-on 等）在模板中是以属性（attribute）
 * 的形式出现在HTML标签上的。即使它们具有动态行为，它们在语法上仍然是HTML属性的一种扩展。
 * 
 * 当Vue解析模板时，它使用正则表达式来识别和提取这些属性。v-if 虽然控制着元素的条件渲染，
 * 但它在模板中的表现形式是一个属性，例如：
 * <div v-if="someCondition">Content</div>
 * 
 * 这里的 v-if 跟随一个表达式 "someCondition"，看起来很像一个动态属性，但实际上，从HTML的角度来看，
 * v-if 就是一个属性名，而 "someCondition" 是其属性值。
 * 
 * 因此，尽管 v-if 和其他Vue指令的行为比普通HTML属性复杂得多，但它们在模板中的语法结构和位置与普通属性相似。
 * 这也就是为什么Vue使用类似于 attribute 的正则表达式来匹配 v-if 和其他指令的原因——它们都是在HTML标签的上下文中被解析的。
 * 
 * 在Vue的源码中，attribute 正则表达式通常会更广泛地匹配HTML属性，而 dynamicArgAttribute 则更专注于匹配那些包含动态表达式的特定Vue指令属性。然而，v-if 的匹配并不一定需要使用 dynamicArgAttribute，因为 v-if 本身就是一个属性，而其后跟随的表达式可以通过正则表达式的进一步解析来识别。
 * 
 * 总的来说，v-if 使用 attribute 正则表达式进行匹配是因为它在HTML模板中表现为一个属性，而其动态特性则是由Vue的解析器和运行时系统在后续步骤中处理的。
 */


/**
 * 用来精确匹配一个完整的HTML结束标签，从</开始，然后是标签名（由qnameCapture定义），接着是可选的属性和空格，最后以>结束。
 */
export const endTag = new RegExp(`^<\\/${qnameCapture}[^>]*>`)

/**
 * 用于识别Vue.js中的指令、事件监听器和绑定。这个表达式用于检测字符串是否以特定的前缀开始，这些前缀与Vue中的不同特性相关联。
 * 
 * 1. process.env.VBIND_PROP_SHORTHAND: 这个环境变量似乎用来判断是否启用了Vue的属性绑定（v-bind）的简写形式。当启用时，你可以用冒号 (:) 来代替 v-bind。例如，v-bind:href="url" 可以简写为 :href="url"。
 * 2. ^v-|^@|^:|^\.|^#: 这是一个正则表达式的字面量形式。它包含一系列的备选项，每个选项都由 ^ 开始，意味着匹配字符串的开始位置。这里有几个不同的前缀：
 *      - ^v-: 匹配任何以 v- 开头的指令，如 v-if, v-for, v-model 等。
 *      - ^@: 匹配事件监听器，如 @click 或 @mouseover。
 *      - ^:: 匹配属性绑定的简写，如 :class 或 :style。
 *      - ^\.: 匹配修饰符，如 .stop 或 .prevent
 *      - ^#: 匹配插槽引用，虽然在 Vue 3 中已被 # 模板引用语法取代 
 */
export const dirRE = /^v-|^@|^:|^\.|^#/ 

/**
 * 用于识别模板中用于属性绑定的指令和符号
 * 1. 属性绑定 (:)：Vue.js 允许使用冒号 (:) 作为属性绑定的快捷方式，它等价于 v-bind。例如，:<attribute-name>="expression" 等同于 v-bind:<attribute-name>="expression"
 * 2. 修饰符 (.)：Vue.js 支持在指令后面添加修饰符来改变指令的行为。例如，@click.prevent 会阻止点击事件的默认行为。
 * 3. 完整的 v-bind 指令：有时，你需要在 v-bind 后面指定一个表达式，例如 v-bind="{ class: isActive }" 或 v-bind:style="dynamicStyle"。
 */
export const bindRE = /^:|^\.|^v-bind:/

/**
 * 用于识别模板中动态绑定的参数，这些参数通常被方括号 ([]) 包围。这种模式常见于 Vue 的动态组件和动态指令参数中。
 * 
 * 动态指令参数
 * 在 Vue.js 中，你还可以使用动态参数来改变指令的行为。例如，动态地改变 v-bind 或 v-on 的参数。
 * 
 * <div :[dynamicKey]="value"></div>
 * 
 * 在这个例子中，dynamicKey 的值将被计算并在运行时决定绑定的属性名。如果 dynamicKey 的值是 "class"，那么这等同于 <div :class="value"></div>
 */
export const dynamicArgRE = /^\[.*\]$/

/**
 * 匹配@ & v-on
 */
export const onRE = /^@|^v-on:/


export const argRE = /:(.*)$/

/**
 * 1. ([\s\S]*?): 这是一个非贪婪匹配模式，它会尽可能少地匹配任何空白字符（\s）和非空白字符（\S）。
 * 这部分通常用于匹配 v-for 后面的别名部分，比如 (item, index)。括号 () 表示这是一组捕获组，可以用于后续提取匹配的文本。
 * 2. \s+: 匹配一个或多个空白字符，例如空格、制表符等。这部分用于匹配别名定义和 in 或 of 关键字之间的空白字符。
 * 3. (?:in|of): 这是非捕获组，意味着它会匹配 in 或者 of 字符串，但不会被捕获以供后续使用。这部分用于识别 v-for 语句中的关键词。
 * 4. \s+: 同上，匹配一个或多个空白字符，这里用于匹配关键词和数据源之间的空白字符。
 * 5. ([\s\S]*): 类似于第一个捕获组，这部分用于匹配数据源，例如 items 或者更复杂的表达式。同样，括号表示这是一个捕获组。
 */
export const forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/

/**
 * 删除括号
 */
export const stripParensRE = /^\(|\)$/g

/**
 * 匹配v-for指令多个变量声明的部分
 */
export const forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/

/**
 * 从字符串中匹配和提取所谓的“修饰符”（modifiers）。在 Vue.js 中，修饰符经常被用在指令后面，用于改变指令的行为。例如，在事件监听器中，你可以添加 .stop 或 .prevent 修饰符来阻止事件冒泡或阻止默认行为。
 * 
 * 1. \.: 匹配一个点字符 .，这是修饰符的开始符号。
 * 2. [^.\]]+: 匹配一个或多个不是点 . 或者方括号闭合 ] 的字符。这将匹配修饰符的名字，修饰符名字中不能包含点或方括号闭合。
 * 3. (?=[^\]]*$): 这是一个前瞻断言（positive lookahead），它不消耗任何字符，但会检查其后的字符是否符合模式。
 * 这里的模式是 [^.\]]*$，意思是直到字符串结束，不应有任何方括号闭合 ] 出现。这个断言确保修饰符的匹配不会跨越到指令以外的其他字符。
 * 4. g: 全局标志，表示在整个字符串中进行多次匹配，而不仅仅匹配第一次出现。
 * 
 * 当这个正则表达式应用于一个字符串时，它将查找所有符合修饰符格式的片段，例如在 @click.stop.prevent 中，它将匹配到 .stop 和 .prevent。
 */
export const modifierRE = /\.[^.\]]+(?=[^\]]*$)/g


export const simplePathRE =
  /^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['[^']*?']|\["[^"]*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*$/

export const fnExpRE = /^([\w$_]+|\([^)]*?\))\s*=>|^function(?:\s+[\w$]+)?\s*\(/
export const fnInvokeRE = /\([^)]*?\);*$/